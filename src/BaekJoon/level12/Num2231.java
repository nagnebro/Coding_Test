package BaekJoon.level12;

import java.util.Scanner;

public class Num2231 {

    public static void main(String[] args) {
//
//        어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.
//        어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다.
//        따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.
//
//        자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
//
//        입력
//        첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

        // 문제를 살짝 꼬아서 냈다.문제속에 함정이 있다
        // 예시를 처음에n으로만 들었다가 m과 n으로 드니까 더욱 헷갈렸다.
        // 여기서 생성자와 분해합의 개념에 대해 확실히 해야한다.
        // 245라는 숫자가 있을 때 (m= 245) 각 자리수의 합(2+4+5)을 n에 더하면 256(n)이 된다.
        // 이떄 245의 분해합은 256이 되고 245는 256의 생성자가 된다.
        // 즉 어떤 수가 주어졌을 떄 그 수의 생성자를 구하라는 것이다. 분해합은 당연히 하나의 수에 한개밖에 가질 수 없다.
        // 그러나 어떤 수의 생성자는 여러개가 있을 수 있다.
        // 예를 들어19의 생성자를 구하라하면  14 가 있다.
        // 그러나 여기서 어떤 규칙성을 찾지는 못하겠어서 더는 예시를 찾지 못하겠다
        // 생성자가 2개이상인 경우는 생각이 안난다.
        //그러나 로직은 비교적 간단하게 구현할 수 있다.
        // 어떤 수 n이 입력되면 합쳐서 n을 만들 수 있는 최소의 수부터 시작해서 for문을 시작한다.
        // 그러므로 입력으로 큰 수가 주어진다고해서 크게 문제될 건 없다.
        // 만들어질 수 있는 최소의 수는 대략 다음과 같다
        // 220이라는 분해합이 주어지면 자리수는 3이다. 이떄 자리수가 999일때 (물론 지금은 세자리수이기때문에 얼토당토 않은 얘기이지만
        // 나중에 자리수가 많아질 경우가 충분히 가능하다) 바로 그 숫자가 생성자일수 있다.
        // 따라서 넉넉하게 n에서 자리수 *10만큼 빼준 상태에서 for문을 시작한다.
        // 백만이 들어와도  7자리수의 10을 곱하면 70만큼 뺀 값과 n사이에 답이 있다.
        // 그러므로 자리수가 바뀌는 거 까지 감안해도 3자리수만 비교하면 답을 구할 수 있는 것이다.
        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        String str2 = str; // 문자열을 인덱싱해야하기 때문에 복사해놓는다.
        int length = str.length();
        int n = Integer.parseInt(str);
        int sum = 0 ; // 자릿수의 합을 구하는 변수.
        int min = n;
        int ranage = n < 20 ? 0 : n-length * 10; // for문을 시작하기위한 초기값의 변수값을 설정해줘여한다.

        for(int i = ranage; 0<=i && i<n ; i++){
            String comp = i+"";
            length = comp.length();
            sum = 0 ;
            for(int j = 0 ; j < comp.length(); j++){
                sum += comp.charAt(j) - ('1'-1);
            }

            // 위에서 sum을 구하는 과정에서는 이를 생략했으므로 한번에 더하고 한번에 빼준다.

            min = sum + i == n && i < min ? i : min;

        }
        min = min == n ? 0 : min;
        System.out.println(min);
    }
}
