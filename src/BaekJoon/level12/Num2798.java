package BaekJoon.level12;

import java.util.Arrays;
import java.util.Scanner;

public class Num2798 {

    public static void main(String[] args) {
//
//        카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다.카드의 합이 21 을 넘지 않는 한도 내에서,
//                카드의 합을 최대한 크게 만드는 게임이다.블랙잭은 카지노마다 다양한 규정이 있다.
//
//                한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.
//
//        김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다.그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다.
//                그런 후에 딜러는 숫자 M을 크게 외친다.
//
//        이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3 장의 카드를 골라야 한다.블랙잭 변형 게임이기 때문에,
//        플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.
//
//        N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3 장의 합을 구해 출력하시오.
//
//        입력
//        첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100) 과 M (10 ≤M ≤300, 000)이 주어진다.둘째 줄에는 카드에 쓰여 있는 수가 주어지며,
//                이 값은 100, 000 을 넘지 않는 양의 정수이다.
//
//                합이 M을 넘지 않는 카드 3 장을 찾을 수 있는 경우만 입력으로 주어진다.
        // 카드의 수는 모두 다르다는 조건이 안 붙어있는데 같은 수를 가진 카드가 여러장있을 수도 있는건가?
        // 우선 Array를 sort시킨 다음에 큰수부터

        // 경우의 수 정리
        // 1.카드로 주어진 수 중에서 m과 가장 가까운수를 고른다. 그리고 그 다음 작은 수를 더했을 때
        // m보다 작은 경우의 수를 만들 수 있는 수중 가증 카드를 1개 더 고른다. 그렇게 1번 더 고르면 3장이 된다
        // 그러나 여기서 조심해야할 것은 예를들어 100 101 102 220 이렇게 카드가 주어졌다 해보자. 이때
        // 카드의 합을 330에 가장 310에 가장 가깝게 만들려면?
        // 220을 먼저골라서는 안된다. 나머지 카드가 모두 220이랑 한번만 더해져도 m보다 커지ㅣ기 때문이다.
        // 그러므로 큰 수부터 찾아야하는데 그러면 경우의 수를 구하는 방법이 너무 많아진다.
        // 예를들어 1 2 3 4 5 6 7 8 과 같이 카드가 주어져있을 때 경우의 수를 구하게되면
        // 이떄 123부터 시작해서(678 부터 시작하든 관게가 없다. 애초에 문제의 m이 어떻게 주어질지 모르기 때문에
        // 작은것부터비교하고 큰것부터 비교하는 것이 의미가 없다.
        // 아무튼 이것의 경우의 수는 1 2 3 / 124/125/126/127/128/
        // 1 34 135 136 137 138.. 145 146...
        // 234/235/236/237... 이런식이 되버린다
        // 그렇다면 시간복잡도 측면에서 바라봤을때 적어도 30만 x 15만 x 15만 정도가 될 것 같다. 50만이라는 근거는
        // for문 변수인 i나 j에 의해 점점 비교하는 것이 줄어들것이기 때문이다.
        // 일단 현재로서는 생각나는 알고리즘이 없으니 이렇게 구현해보자.. 3중 for문이다
        // 1. 백의 자리수 이동
        // 2. 십의자리수 이동
        // 3. 일의자리수 이동.


        // 이 문제에서 카드 개수는 100으로 제한돼있고
        // m이 30만이다. 그러나 카드 개수가 30만이라고 가정하면 다음과 같다.
        // 1. 30만번을 스캐너의 nextInt()로 받으면 입출력 오버헤드가 커진다.
        // 2. 하나의 문자열로 받은 후 split시킨 다음(이때 배열의 메모리 사용량이 굉장히 커질것)
        // 30만번 파싱시킨다.
        // 일반적으로는 2번의 경우가 더 효율적이라고는 하지만 테스트케이스를 작성해봐야 알 수 있다고 한다
        // 나는 2번의 방법으로 진행한다.
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt(); // 이렇게 넘어가면 개행문자가 nextLine으로 넘어가므로 한번 더 처리한다.
        sc.nextLine();
        String str = sc.nextLine();
        int max = 0;
        String[] before_parsing = str.split(" ");
        int[] array = new int[n];


        for (int i = 0; i < n; i++) { // 문자열로 받은 배열을 정수형 배열로 초기화한다.
            array[i] = Integer.parseInt(before_parsing[i]);
        }


        for (int i = 0; i < n - 2; i++) {

            for (int j = i+1; j < n - 1; j++) {

                for (int k = j+1; k < n; k++) {


                    int sum = array[i] + array[j] + array[k];
                    max = sum > max && sum <= m ? sum : max;

                }
            }
        }
        System.out.println(max);

    }
}
